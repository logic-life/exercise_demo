shared_ptr 的构造函数是explicit，所以不接受隐式转换。
故返回智能指针的函数不允许在返回语句隐式转换一个普通指针。
shared_ptr<int> p(new int(45));//采取直接初始化。

不能使用内置指针访问智能指针所负责的对象，因为无法知道对象何时会被销毁。

shared_ptr只有使用shared_ptr直接初始化才会生成动态对象共享，如果使用内置类型初始化，
会默认为是由两个地址创建的指针。
process(shared_ptr<int>(p.get()))//p.get()会返回一个内置指针。

智能指针可以保证程序块即使出现异常确保内存不在需要的时候将其释放，
但是内置指针不行。

智能指针陷阱：
不使用相同的内置指针（reset）初始化多个智能指针。
不delete get()返回的指针
不使用get()初始化或者reset另一个智能指针
如果使用get()返回的指针，当最后一个对应的智能指针销毁后，对应的指针变得无效了
使用智能指针管理的资源不是new分配的内存，需要传递一个删除器。
